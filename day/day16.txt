day16 
복습 -> 예외처리 -> api -> streamAPI -> Object클래스 -> wrapper클래스 -> 컬렉션 프레임워크

0. 복습
1) 내부클래스
	클래스 내부에 선언된 클래스를 의미한다
	내부클래스 객체화는 외부클래스가메모리에 할당되어야만 가능하다
	내부클래스로 선언된 클래스는 외부클래스를 상속받지 않아도 외부 클래스 멤버 사용이 가능하다

	인스턴스 내부클래스
	정적 내부클래스
	로컬 내부클래스

2) 익명클래스
	이름이 없는 클래스
	미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해서 사용한다
	부모클래스를 상속받는 익명 자식 객체
		new 부모생성자(매개변수){
			//필드, 메소드(오버라이딩)
		{;

	인터페이스를 구현하는 익명 구현 객체
		해당 타입의 필드, 로컬변수, 매개변수의 값으로 대입가능하다
		new 인터페이스(){
			//메소드(오버라이딩)
		}

3) 람다식 : 익명메소드
	함수형 프로그래밍은 함수를 정의하고 이 함수를 데이터를 처리하는 쪽으로 보내 데이터를 처리하는 기법
	데이터를 처리하는 쪽에서는 데이터만 가지고 있고 처리방법이 따로 정해져있지 않아 외부에서 제공된 함수에 의존한다

	java는 함수형 프로그래밍을 위해 8부터 람다식, 스트림API을  지원하고 있고 
	데이터를 처리하는 쪽에 제공되는 함수 역할을 하는 매개변수를 가진 중괄호 블록을 의미한다
	데이터 처리부는 람다식을 받아 매개변수에 데이터를 대입하고 중괄호를 실행시켜 처리한다

	함수형 인터페이스
	@FunctionalInterface

	함수형 인터페이스로 추상메소드가 한 개만 선언되어있을 떄 람다식으로 재정의 가능하다
	메소드를 하나의 식으로 표현한다
	
1.	매개변수명 -> 명령문1
	(매개변수1, 매개변수2) -> {명령문1; 명령문2; return 값;}

	람다식 문법
	- 매개변수가 하나인 경우 자료형 괄호 생략가능
	- 매새변수가 두개 이상인 경우 소괄호 생략불가
	- 실행할 문장이 한 문장일 경우 중괄호, 세미콜론 생략가능
	- 실행할 문장이 한 문장이라도 return문일 경우에는 {} 생략시 return 생략가능, {}생략하지 않으면 return작성

1. 예외처리

1) 오류의 종류
	에러(Error)	: 개발자가 해결할 수 없는 문제(코드로 수습 불가)
	예외(Exception)	: 개발자가 해결 가능한 문제(코드로 수습 가능)

2) 예외의 발생 시점
	확인된예외(checked exception, 일반예외)
		컴파일 단계에서 발생하는 예외(이클립스 빨간줄)
	미확인예외(unchecked excption, 실행예외 Runtime Exception)
		프로그램 실행 중(런타임) 발생하는 예외

	자바의 모드 예외클래스는 Throwwable을 상속받은 클래스로 만들어지고
	예외 클래스는 Exceptoin 클래스를 상속받는다
	실행예외는 RuntimeException과 해당 클래스를 상속받는 자식클래스이고
	그 밖의 예외는 모두 일반 예외이다

3) 예외처리
	예외가 발생했을때 프로그램이 비정상적으로 종료되는 것을 막고 정상적으로 실행될 수 있도록 처리하는 것을 의미한다

	try{
		예외가 예상되는 코드
	}catch(예외이름 객체명){
		예외를 처리하는 명령문
		(예외발생 시 실행할 코드)
	}catch(예외이름 객체명){
		예외를 처리하는 명령문
		(예외발생 시 실행할 코드)
	}...
	{finally{
		예외발생 여부에 상관없이 무조건 실행할코드
		//생략가능
	}
	
	try불록에서 작성한 코드가 예외없이 정상 실행되면 catch블록은 실행되지 않고 finally문이 실행된다
	catch는 위에서부터 검사하므로 위에서 예외가 잡히면 다른 catch문은 건너뛰고 finally문이 실행된다

4) 예외 클래스에서 제공하는 메소드
	자바에서는 발생할 수 있는 예외들을 클래스로 정의해두었다
	만약 실행중 오류가 발생하면 해당 오류클래스의 객체가 생성된다(메모리에 할당된다)
	예외처리를 해두었다면 그 객체의 주소를 catch(예외클래스 참조변수)의 참조변수가 받게된다
	예외클래스에는 다양한 기능을 제공한다
	
- .getMessage() : 예외 메시지를 문자열로 반환
- .toString()	: 발생한 예외 객체를 문자열로 반환
		생략가능, 참조변수를 출력하면 자동으로 toString()가 사용됨
- .printStackTrace() : 예외가 발생지점을 추적하여 단계별로 전부 출력함

	=> 예외처리를 적절하게 수행하면 프로그램의 안정성을 높이고, 신뢰성 있는 프로그램을 만들 수 있다


5) throws와 throw
	메소드 내부에서 예외가 발생할 때 try-catch블록으로 예외를 처리하는 것이 기본이지만 메소드를 호출하는 곳을
	예외처리를 떠넘길 수 있다

- throws : 예외 던지기, 메소드의 선언부에 사용한다
   메소드에서 발생할 수 있는 오류를 메소드를 정의할 때 처리하지 않고
   해당 메소드를 사용하는 쪽으로 던져서 메소드를 사용하는 개발자가 처리하도록 한다
   (상황에 맞게 예외처리하기 위함)
   ex) void method1() throws 예외클래스명 {}
   ex) void method2() throws 예외클래스명, 예외클래스명 {}

- throw : 예외를 발생시킨다(강제 예외 발생시키기)
   ex) throw new 예외명();

=> try{}catch(예외클래스명 참조변수){}
	참조변수.printStackTrace()
	참조변수.toString()
	참조변수. getMessageg()
=> throws	예외 던지기, 메소드 선언부에 작성
=> throw	에외 강제로 발생시키기

6) 사용자 정의 예외
	사용자 정의 예외는 컴파일러가 체크하는 일반 예외로 선언할 수도 있고,
	컴파일러가 체크하지 않는 실행예외로 선언할 수도 있다

	일반예외은 Eexception 클래스를 상속받는 자식 클래스로 선언하고
	실행예외는 RuntimeException 클래스를 상속받는 자식 클래스로 선언한다
	
	기본 생성자와 예외메시지를 입력받는 생성자를 선언해주거나 super()에 예외메시지를 전달한다
	
	public class 예외명 extends Exceptiong or RuntimeException{
		생정자(){
			super("사용자정의예외메시지");
		}

	}

2. API(Application Programming Interface)
	응용 프로그래밍 인터페이스

	내부 API
		JDK(JRE, JVM) 설치 시 제공해주는 기본 api
		자바로 어플리케이션을 쉽게 구현할 수 있또ㅗㄱ 한 라이브러리 집함
		https://docs.oracle.com/en/java/javase/17/docs/api/index.html

	외부 API
		다른 개발자들이 개발한 패키지 및 클래스들을 의미한다
		보통 jar 파일로 배포하며 자바 프로젝트에 build path에 추가하여 사용할 수 있다

1) API 공식문서 확인
	- 전체 상속관계를 보려면 상속 계층도를 보면된다
	- api 도큐먼트에서 String 클래스가 어떻게 정의되어있는지는 아래쪽에 있는 선언부를 보면된다
		클래스가 final인지 추상클래스인지 알 수 있고, 부모클래스나 구현 인터페이스도 볼 수 있다
	- 구성멤버는 상단 메뉴에 SUMMARY를 보면된다
		멤버별 링크를 제공하는데 링크가 있으면 public, protected 공개된 멤버가 있다는 의미이고
		링크가 없으면 공개된 멤버가 없다는 뜻이다


2) 모듈, 패키지, 라이브러리
- 모듈(Module)
	자바 9버부터 도입된 모듈 시스템
	코드를 논리적으로 그룹화하고 모듈간의 의존성을 관리하는 방법을 제공한다
	모듈은 패키지와 라이브러리의 개념을 확장하고 런타임에서 모듈의 논리적인 단위로 코드를 로드하고 관리할 수 있다
	코드의 의존성을 더욱 명확하게 정의하고 런타입 모듈 시스템을 통해 더 격리된 환경을 제공한다

- 패키지(Package)
	관련된 클래스 및 인터페이스를 그룹화 하는 방법을 제공한다
	패키지는 디렉토리 구조와 일치하고 패키지 내의 클래스들은 동일한 패키지 이름 공간안에 있어야한다
	코드를 구조화하고 이름 충돌을 방지하는데 도움을 준다

- 라이브러리(Library)
   	jar(Java Archive) 압축파일 형태로 존재한다 
   	jar파일에는 클래스와 인터페이스의 바이트코드(.class)파일들이 압축되어있다

 	재사용 가능한 코드 집합
  	특정 작업 또는 기능을 수행하기 위해 다른 프로그램에서 사용할 수 있게 해준다

3) 외부 API
	JAR파일로 만든다
	Java Archive : java 클래스파일, 리소스 파일 및 메타데이터를 포함하는 아카이브 파일

- Jar 파일 생성
	java 어플리케이션을 개발한 모든 파일들을 jar파일로 패키징

- Jar 파일 배포
	jar파일을 웹사이트, FTP서버, 클라우드 저장소 등에 업로드하여 배포가능

- JAr 파일 실행
	jar파일을 실행하려면 Java Runtime Environment(JRE)가 필요하다
	Java -jar [jar 파일명]

Jar 파일 배포
	배포할 프로젝트 마우스 우클릭 > Export > JAVA/JAR file 선택 > Next
	> Destination 원하는 경로로 선택 > Export Java Source files .. 체크(API 주석 포함하겠다)
	> Finish

외부 API Build Path에 추가 
	배포된 jar 파일 다운로드 > 프로젝트 우클릭 > Build Path > Configure Build Path
	> Libraries 탭 클릭 > Add External JARs 클릭 > 저장된 경로의 .jar파일을 더블 클릭으로 추가 > Apply 클릭
	> Orders and Exports 탭 클릭 > Select All클릭 > Apply and Close 클릭

3. Stream API
	Java 8에서 도입된 기능
	함수형 프로그래밍을 지원하며 데이터의 흐름을 기반으로 하는 API
	컬렉션 데이터를 효과적으로 처리하고 조작하는데 사용된다
	데이터를 선언적으로 처리할 수 있다
	
+) 선언적 언어	VS	명령적 언어
		선언적				명령적
초점		무엇을 해야하는지 정의			어떻게 해야하는지 정의
코드작성		간결하고 읽기 쉬움			절차적이고 복잡해질 수 있음
제어흐름		실행방법은 추상화			실행방법을 상세히 기술
예시		Stream API, SQL, HTML,CSS	for, 조건문, ..


1) 스트림(Stream)
	데이터의 흐름을 추상화한 것, 배열, 컬렉션, I/O 자원에서 데이터를 처리하기 위한 API
	데이터를 한 번만 소비, 기존 데이터 원본을 변경하지 않음
	=> 한 번만 소비한다는 것은 데이터를 처리한 뒤 재사용 할 수 없다, 필요하면 새로운 스트림을 생성해야한다
	(데이터를 순회하고 결과를 반환한 후에는 다시 사용할 수 없음을 의미하며 원본데이터를 절대 변경하지 않는다)
	=> 원본 데이터를 안전하게 유지한다

2) 스트림 연산
- 중간연산 : 스트림을 변환하는 작업, 결과가 또 다른 스트림으로 반환됨
	지연실행(Lazy Evaluation : 최종연산이 호출 될 때 실행
	연속적으로 연결가능(메소드 체이닝)
	filter(조건)	: 조건에 맞는 요소만 남김
	map(함수)		: 각 요소를 변환
	sorted()	: 요소를 정렬
	distinct()	: 중복요소 제거
	limit(long)	: 처음 n개 요소만 가져옴
	skip(long)	: 처음 n개 요소를 건너뜀

- 최종연산 : 스트림을 처리하고결과를 반환하거나 출력하는 작업
	스트림 파이프라인의 끝을 나타냄
	최종 연산 후 스트림은 더 이상 사용 불가능
	
	collect(collector) : 스트림의 결과를 컬렉션 등으로 반환
	forEach(Consumer) : 각 요소를 소비 => forEach(System.out::println) - 메소드참조
	count() : 요소의 개수를 반환
	reduce(BinaryOperator) : 스트림 요소를 누적

+) 메소드 참조
	기존 메소드를 간결하게 호출하기 위한 표현식
	ClassName::staticMethod
	ObjectName::insanceMethod
	ClassName::new(생성자참조)

3) 스트림 소스(Source)
	스트림을 생성하는 데이터 원본

	배열 : Arrays.stream(array)
	컬렉션 : List.stream(), Set.stream()
	숫자 범위 : IntStream.range(1, 10)
	
4. Object클래스
	java.base 모듈
	java.lang 패키지
		Object클래스	자바 클래스 최상위 클래스 사용
		System		키보드로부터 데이터를 입력받기 위해 사용
				모니터(콘솔)로 출력하기 위해 사용
				프로세스 종료시킬 때 사용
				진행시간을 읽을 때 사용
				시스템 속성(프로퍼티)을 읽을 때 사용
	문자열관련 String		문자열을 저장하고 조작할 때 사용
		StringBuilder	효율적인 문자열 조작기능이 필요할 때 사용
	포장관련 	Byte, Short,	기본 타입의 값을 포장할 때 사용
		Integer, Double,	문자열을 기본 타입으로 변환할 때 사용
		...
		Math		수학 계산이 필요할 때 사용
		Class 		클래스의 메타정보(이름, 구성멤버) 등을 조사할 때 사용

1) Object 클래스
	모든 클래스의 최상위 부모 클래스
	
	boolean equals(Object obj)	객체의 번지(주소값_을 비교하고 결과를 리턴
	int hashCode()			객체의 해시코드를 리턴
	String toString()		객체 문자 정보를 리턴

2) toString()
	Object의 toString()은 참조값을 문자열 형태로 출력한다
	참조변수를 print()등의 출력 메소드로 출력하면 항상 toString()이 사용된다 => 참조값이 나오는 이유
	toString()을 통해 출력되는 문자열을 바꾸고 싶다면 재정의해서 사용한다

----------------------------------------------------------------------------------------------
1. 숫자를 입력받아 1부터 입력받은 숫자까지의 합을 출력하는 프로그램을 만드세요. 
그리고 숫자가 아닌 값이 입력될 경우 "잘못된 입력입니다"라는 예외 메시지를 출력하고, 
프로그램을 종료하세요.

2. 문자열을 입력받아, 입력받은 문자열을 정수로 변환하여 출력하는 프로그램을 작성하세요. 
만약 입력받은 문자열이 숫자가 아닐 경우, NumberFormatException 예외가 발생하게 되며, 
"숫자가 아닌 문자열이 입력되었습니다"라는 메시지를 출력하세요.

3. 사용자로부터 정수를 입력받아, 입력받은 정수가 0에서 100 사이의 값인 경우, 
입력받은 정수를 2배한 값을 출력하고, 그 외의 값이 입력될 경우 
"잘못된 입력입니다"라는 예외 메시지를 출력하세요.

4. 사용자로부터 숫자를 입력받아, 입력받은 숫자가 3의 배수인 경우 "Fizz", 
5의 배수인 경우 "Buzz", 3과 5의 공배수인 경우 "FizzBuzz", 
그 외의 경우에는 입력받은 숫자를 출력하는 프로그램을 작성하세요. 
사용자가 문자열을 입력할 경우, "숫자가 아닌 문자열이 입력되었습니다"라는 예외 메시지를 출력하세요.


































































































