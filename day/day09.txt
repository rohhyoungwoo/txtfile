day09
복습 -> 메소드2 -> 클래스1

0.복습
1) 배열의 사용 목적
	- 데이터 정렬, 검색하기 위함
	- 데이터 집합을 효율적으로 관리하기 위함
	- 메모리를 효율적으로 사용하기 위함
	- 데이터의 순서를 보존하기 위함
	- 반복문을 사용하여 배열의 요소를 처리하기 위함

2) 배열 
	변수 : 하나의 자료형으로 하나의 값을 저장공간
	배열 : 하나의 자료형으로 여러가지 값을 저장공간

	//칸수만 알고 있을 때
	자료형[] 배열명 = nex 자료형[크기];
	
	//값을 알고 있을 때
	자료형[] 배열명 = [값, 값, 값, ..};

	//값을 모르고 나중에 생성할 때
	자료형[] 배열명;
	배열명 = new 자료형[]{값, 값, 값};

	null	: 주소값을 모를 때 사용한다
	new	: heap 메모리 시작주소값

4) 배열의 구조
	int[]		ar	=	new	int[3];
		--------------		-----------------
		stack 메모리, 참조변수	heap 메모리, 참조값
		[시작주소==참조값]		[0][0][0]
					0  1  2

5) 2차원 배열
	//칸(행과 열)을 알고 있을 때
	자료형[][] 배열명 = new 자료형[행][열];
	
	//값을 알고 있을 때
	자료형[][] 배열명 = {{값, 값},{값,값,}};

ar.length 행의 길이	ar[0].length 열의 길이
6) 반복문과 배열
	1차원 배열 => int[] ar = {1, 2, 3, 4};

	syso(ar);	//참조값
	for(int i = 0; i < ar.length; i++{
		syso(ar[i]);
	}

	for(int data : ar){
		syso(data);
	}

	//2차원배열 => int[][]	ar2 = {{1, 2}, {3, 4}, {5, 6}};

	for(int[] i : ar){
		for(int data : i){
			syso(data);
		}
	}

	for(int i = 0; i < ar2.length; i++){
		for(int j = 0; j < ar2[i].length; j++)"{
			syso(ar2[i][j]);
		}
	}

7) 메소드
	기능
	어떠한 기능을 하는 코드들의 묶음
	이름뒤에 소괄호
	
	함수 : 클래스 외부에 선언되어있는 것
	메소드 : 클래스 내부에 선언되어 있는 것

8) 메소드 정의
	리턴타입 메소드명(자료형 매개변수)	<- 선언부
	{				<- 구현부
		실행할문장;
		return 리턴값;
	}

9) 메소드 호출 방법
	매개변수	리턴값	메소드 정의						메소드호출
	x	x	void 메소드명(){ }					객체명.메소드명();
	o	o	String 메소드명(자료형 매개변수){return "문자열"}		syso(객체명.메소드명(인수));
									String 변수 = 객체명.메소드명(인수);
	o	x	void 메소드명(자료형 매개변수){}			객체명.메소드명(인수);
	x	o	Double 메소드명(){return 0.0}			syso(객체명.메소드명()
return - 값이 저장 되어있다. 전체를 값으로본다 - 출력, 변수 저장

10) 메소드 정의와 사용
	정의 {}중괄호가 있고 반드시 메소드 밖에서 정의한다
	사용 {}중괄호가 있고 

11) 메소드 정의 순서
	리턴타입 메소드명(자료형 매개변수, ..)	<-선언부
	{				<- 구현부
		실행할문장;
		return 리턴값;
	{

- 기능을 실행한다(두개의 값을 더하는 기능)
- 리턴타입을 생각한다. 생각나지 않으면 void로 작성하다
	void
- 기능에 맞는 메소드명을 작성한다(동사로 작성한다)
	void add
- 매개변수를 생각한다
	void add(int num1, int num2)	<- 선언부
	{ }				<- 구현부
- 리턴값을 생각한다
	void add(int num1, int num2)
	{
		syso("num1 = " + num1 + ", num2 = " + num2):
		int result = num1 +num2;
		return result;
	}

매개변수 x 리턴값 x => 메소드명();
매개변수 x 리턴값 o => syso(메소드명());
매개변수 o 리턴값 x => 메소드명(인수);
매개변수 o 리턴값 o => syso(메소드명(인수));

1. 메소드
1) 메소드와 메모리
	메소드는 실행되면 메모리의 Stack영역에 메소드 실행에 필요한 저장공간이 생성된다
	그 곳에 메소드 내부에서 선언한 변수(지역변수, 매개변수)들의 저장공간이 생성된다
	메소드의 코드가 모두실행되어 종료되면 Stack 영역에서 해당 메소드의 저장공간이 삭제된다(메모리 해제)
	그러면 지역변수의 저장공간이 사라지므로 지역변수는 사용이 불가능하다

+) 스택 프레임의 장점
	메모리 관리 효율성 : 메소드를 호출 할 때 필요한 메모리를 동적으로 할당하고, 호출이 끝나면 자동으로 해제한다
	재귀적 호출 지원 : 재귀 호출에서 각 호출마다 독립적인 스택 프레임이 생성되어, 서로 간섭없이 수행된다
	지역성 : 스택 메모리 접근 속도가 빠르며, 지역변수와 매개변수는 메모리 접근 비용이 적다

2) 인수와 매개변수
	인수(Argument) : 메소드를 사용할 때 메소드의 매개변수로 전달될 값
	매개변수(Parameter) : 외부에서 잔달받아 값을 저장하고 메소드내에서 사용될 변수

	- 메소드의 인수와 매개변수는 반드시 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다
	- return되는 값은 반드시 return 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다

3) 메소드의 사용 목적
	- 중복된 코드의 제거
	- 높은 재사용성
	- 유지보수에 유리함

4) 메소드 오버로딩(Method Overloading) => 다형성 : 같은 코드로 다른 기능을 하는 것
	Method : 메소드(작업을 수행하는 코드 블록) {}
	Overloading : 과부하, 너무 많이 실음 이라는 뜻, 프로그램에서는 같은 이름을 여러번 사용하는 것을 의미

	같은 이름의 메소드를 여러개 정의하는 것을 의미한다
	매개변수의 개수, 타입, 순서가 다르면 같은 이름의 메소드로 선언할 수 있다
	반환타입은 오버로딩에 영향을 주지 않는다

	void add(int n1, int n2){
		syso(nu1 +

- 메소드 오버로딩의 조건
	리턴타입은 같아도 상관없음
	메소드의 이름은 동일해야함
	매개변수의 타입, 개수, 순서가 달라야함

- 메소드 오버로딩의 주의사항
	매개변수의 타입, 개수, 순서가 똑같은 경우 매개변수의이름이 다르다고 해서 오버로딩이 아니다
	리턴타입만 다르고 메소드의 이름과 매개변수가 동일한 경우에도 오버로딩이 아니다

- 메소드 오버로딩이 필요한 이유?
	- 이름의 통일성 : 비슷한 작업을 수행하는 메소드는 같은 이름을 사용하면 직관적이다
	- 코드 가독성 : 여러 작업을 하나의 이름으로 처리할 수 있어 코드가 간결해진다(메소드 이름을 따로 기억할 필요가 없다)

- 메소드 오버로딩이 가능한 이유
	컴파일러가 메소드 호출 시 메소드 이름뿐만 아니라 매개변수의 정보를 사용해
	정확히 어떤 메소드를 호출할 지 구분하기 때문이다

	컴파일 시 메소드 이름이 다르게 지정됨
		컴파일러는 메소드의 이름과 매개변수의 정보를 합쳐서 고유한 시그니처(Method Signatrue)를 생성
		시그니처는 메소드이름 + 매개변수의 타입과 개수로 구성

- 컴파일러가 메소드를 선택하는 과정
	매개변수의 개수 확인 : 메소드 호출시 인수값의 개수와 일치하는 메소드를 먼저 찾는다
	매개변수의 타입 확인 : 메소드 호출시 전달된 인수값의 타입과 일치하는 메소드를 찾는다
	타입 변환 규칙 적용 : 전달된 인수값의 타입과 완전히 일치하는 메소드가 없을 경우, 더 큰 타입으로 변환가능한
			메소드를 호출(작은 타입의 값은 큰 타입으로 자동형변환이 가능하기 때문)
			int -> long, float, double순으로 자동변환 가능
			큰타입이 호출 우선순위의 뒤에 있다

* 메소드 호출방법 4가지
매개변수 o 리턴타입 x - .메소드명(인수);
매개변수 o 리턴타입 o - syso(객체명.메소드명(인수));
매개변수 x 리턴타입 o - syso(객체명.메소드명());
매개변수 x 리턴타입 x - .메소드명();

매개변수	리턴값	메소드 호출
x	x	객채명.메소드명();
o	x	객체명.메소드명(인수);
x	o	syso(객체명.메소드명()); or (리턴값을 따라간다)자료형 변수명 = 객체명.메소드명();	
o	o	syso(객체명.메소드명(인수)); or 자료형 변수명 = 객체명.메소드명(인수);

* 메소드 오버로딩
	다형성을 구현하는 한 방법
	같은 이름의 메소드명으로 매개변수의 순서, 개수, 타입이 다르면 선언할 수 있다

* 배열 선언과 생성
//칸수 알때
	자료형[] 배열명 = new 자료형[칸수];
//값 알 때
	자료형[] 배열명 = {값, 값, ...};
//배열변수만 선언할 때
	자료형 [] 배열명 = null;
//선언과 생성을 따로할 때
	자료형[] 배열명;
	배열명 = new 자료명[]{값, ...};

//2차원
//칸수일 때
	자료형[][] 배열명 = new 자료형[행][열];

//값을 알 때
	자료형[][] 배열명 = {{값, 값}, {값, 값}. {값, 값}}; //열이 같을 때
	자료형[][] 배열명 = {{값}, {값, 값}. {값, 값, 값}}; //열이 다를 때


값을 모를 때
자료형[]변수명 = 자료형[0];

값을 알 때
자료형[] 변수명 = {{값1, 값2, 값3}};


* 입력받은 숫자까지 총합 구하는 메소드(매개변수 o, 리턴타입 o)
로직구성
	//main{



	}
	//printsum{
	//1) 리턴타입 void => int
	//2) 메소드명 printSum
	//3) 매개변수 int num
	//4) 구현부 => 총합저장할 변수 선언
	//5) 		for문(초기식 : int i = 1; 조건식 : 매개변수에 전달받은 값만큼; i++){
	//6)		총합 += i; }
	//7)		return 총합;{

	static int printSum(int num){
		int sum = 0;
		for(int i =1; i <= num; i++){
			sum += i;

		}
		return sum;
		}


얕은 복사 => 참조값이 복사(원본과 복사본이 서로 의존적), 속도 빠름, 메모리 사용량은 적음, 간단한 객체나 데이터 구조
깊은 복사 => 모든 데이터 복사(원본과 복사본이 독립적), 데이터양에 비례 느림, 메모리 사용량은 많음, 데이터의 독립성이 중요

2. call by value와 call by reference
	=> 메소드 호출 시 매개변수를 전달하는 방식

1) Call by Value(Pass by Value) : 값에 의한 호출
	값을 복사하여 메소드에 전달하는 방식
	메소드 호출 시 원본값이 복사되므로, 메소드 내부에서 값이 변경되어도 원본에는 영향을 미치지 않음

	메소드에 인수로 전달되는 것은 변수의 값 자체
	- 메소드 내부에서 값을 변경해도 원본 변수는 변경되지 않음
	- 기본 데이터 타입에서 사용

2) Call by reference(Pass by Reference) : 참조에 의한 호출
	참조를 전달하여 메소드에 직접 원본 데이터를 조작할 수 있는 방식
	메소드 호출 시 데이터의 주소(참조값)가 전달되므로, 메소드 내부에서 데이터를 변경하면 원본 데이터도 변경됨

	- 메소드 내부에서 참조된 객체를 수정하면, 원복 객체도 변경됨
	- C++ 등의 언어에서 지원되며, JAVA는 지원되지 않음


		기본 데이터 타임			참조타입
전달방식 		값 자체를 복사하여 전달		참조값(주소)을 복사하여 전달
원본데이터변경여부	메소드 내부 변경이 원본에 영향없음	참조된 객체를 변경하면 원본 객체에도 영향 있음
참조값 변경여부	의미없음				참조값 자체를 변경해도 원본 참조값에는 영향 없음

+) JAVA 동작
	JAVA는 항상 Call by Value로 동작한다
	기본 데이터 타입 : 값 자체가 복사되어 전달
	참조 타입 : 객체의 참조값(주소)이 복사되어 전달되므로 객체 내부의 데이터는 수정할 수 있지만 참조값 자체는
		변경되지 않는다
	* 참조타입의 동작이 Call by Reference 처럼 보일 수 있지만 실제로는 참조값의 복사(Call by Value)이다

	기본 데이터 타입 : stack 메모리에 값 자체가 저장된다
	참조타입 : stack 메모리에 참조값이 저장되고, 객체 자체는 heap 메모리에 저장


3. JVM 메모리에 변수가 저장된느 위치
	기본자료형 : boolean, byte, short, int, float, double, char
	참조자료형 : 배열, enum, class, interface, 기본형을 제외한 모든 것들
----------------------------------------------------------------------------------------------
*
1. 메소드에 대한 내용을 모두 같이 공유해서 노션에 정리하기(개념 정리)
	* 파트 나눠서 내용 정리(팀원 설명)

2. 3문제 만들기(변수~메소드)

	















	
