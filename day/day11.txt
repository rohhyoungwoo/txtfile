day11
클래스 -> 객체 -> 생성자 -> 오버로딩 -> this, this()

0. 객체지향언어(Object-Oriented Programming, OOP)
   프로그램을 객체로 구성하고 이 객체들 간의 상호작용을 통해 문제를 해결하는 방식

1) 캡슐화(Encapsulation)
   객체의 데이터를 보호하고 외부에서 접근할 수 있는 방법을 제한하는 개념
   객체 => 데이터를 포함한 속성과 동작을 정의하는 메소드를 하나로 묶은 것을 의미
   객체 외부에서 내부 데이터를 직접 변경하지 못하게하고 허용된 메소드를 통해서만 데이터를
   변경하거나 사용할 수 있게 한다
   데이터(필드)를 private 접근제한자를 선언하여 외부에서 직접 접근하지 못하게 하고
   getter, setter 메소드를 통해서만 필드에 접근하도록 한다

2) 다형성(Polymorphism)
   다형성을 통해 같은 이름의 메소드가 객체에 따라 다르게 동작하도록 한는 것을 의미
   메소드 오버로딩, 메소드 오버라이딩, 참조변수의 다형성

3) 상속(Inheritance)
   기존 클래스의 필드와 메소드를 자식 클래스가 물려받는 상속을 지원한다
   상속은 extends 키워드를 사용한다
   단일상속만 지원한다(한번에 하나의 부모클래스만 상속 가능)

4) 추상화(Abstraction)
   불필요한 세부구현을 숨기고 중요한 부분만 노출하는 것을 의미한다
   추상클래스, 인터페이스

5) 클래스와 객체
   모든 데이터를 클래스의 형태로 정의하며 객체는 클래스의 인스턴스
   클래스는 객체의 설계도 역할을 하며, 필드(속성)와 메소드(동작)을 정의한다

1. 클래스
   추상화된 클래스로 객체를 만들고 객체들 간의 관계를 맺어 상호작용하는 프로그래밍 기법
   추상화? (객체모델링)
      공통적인 특징을 파악하여 하나의 묶음으로 만들어내는 것

0) 쉬운 설명
- 클래스?         비슷한 특징을 가진 것들을 묶어서 만든 일종의 설계도면
         사람들 설계도면 => 사람클래스

- 클래스안에 있는것?   설계도면에 따라 만들어진 물건들을 위한 특징(속성)과 물건이 할 수 있는 행동(메소드)
         사람클래스 => 필드 : 이름, 나이, 핸드폰번호, 혈액형, 주소, 주민번호, ...
              메소드 : 걸을 수 있다, 문자를 보낼수있다, 잘수있다, 먹을 수 있다, 공부할 수 있다,..
   
- 속성?      이름, 나이, 성별, 핸드폰번호, ..   => 사람이 가지고 있는 특징
- 메소드?      걷기, 말하기, 먹기, 공부하기, ...   => 사람이 할 수 있는 행동

- 객체?      클래스를 만들면 그 설계도면에 따라 실제 물건(객체)를 만들 수 있다
      사람클래스 => 영선 객체명을 가진 사람을 만들수 있고, 현택이라는 이름 사람도 만들 수 있다
         각 사람은 자신의 특징을 가지고 있고, 행동을 할 수 있다

1) 클래스(classBasic2 패키지 참고)
- 사용자 정의 타입이다(자료형)
   클래스를 사용하면 여러 타입, 여러 값을 저장할 수 있는 저장 공간을 만들 수 있다
   클래스 안에 선언된 변수를 사용하고 싶다면 해당 클래스 타입으로 변수를 선언해야한다
   
   변수 : 하나의 자료형으로 하나의 값만 저장할 수 있는 저장공간
   배열 : 하나의 자료형으로 여러가지 값을 저장할 수 있는 저장공간

- 연관성 있는 저장공간과 기능을 한 곳에 모아 편하게 관리할 수 있는 것
   저장공간과 기능을 나누어 관리하게 되면 코드가 길어졌을 때 사용하기 불편한다
   이 때 연관되는 저장공간과 기능을 클래스로 묶어서 관리할 수 있다

- 객체를 생성하기 위한 틀, 설계도(면)
   공통되는 속성(변수)과 행위(메소드)를 한 번만 선언해 놓고 가져다 사용만 할 수 있도록 설계한다
   추상적인 것(클래스)를 구체화시키면(메모리에 생성된 것) 객체라고 한다

2) 객체(Object)와 인스턴스(Instance)
2) 2) 객체(Object)와 인스턴스(Instance)
   객체 : 실제 사물 또는 개념
   클래스 : 객체를 컴퓨터에 옮기기 위해 추상화 한 것, 실제 존재하는 공간이 아니며 추상적이다
   인스턴스 : 클래스를 메모리에 할당시킨 것이며 물리적으로 존재하는 공간, 구체적이다

3) 클래스 선언
   class 클래스명{
      //class를 구성하는 필드와 메소드를 합쳐서 멤버라고 부른다
      필드;   //멤버변수, 전역변수

      메소드(){} //멤버메소드
   }

   객체화(인스턴스화)
      객체를 만드는 작업, 추상적인 개념을 구체화 시키는 작업
      클래스명 객체명 = new 클래스명();
      클래스명 참조변수명 = new 생성자();

   객체 사용 방법
      객체명.멤버명
      . : 하위연산자, 멤버접근연산자, 닷연산자

+) 객체를 생성하고 참조변수에 저장하는 과정

   class MyClass{
      void myMethod(){}
   }   

   public class Main{
      main(){
         MyClass    refVar    =      new MyClass();
         자료형(클래스)   참조변수   대입연산자      new 생성자();
         ----------------------   --------   --------------
            1번      		3번     		 2번

      }
   }

1번 : refVar라는 참조 변수는 main()메소드라는 영역에서 만들어진 지역변수이므로 JVM이 관리하는 메모리의 Stack영역에 생성된다
	데이터타입은 참조하려는 대상과 같은 자료형이어야하므로 MyClass라고 지정한다

2번 : new 키워드가 Heap 메모리에 MyClass객체를 생성하고 참조값을 가져온다

3번 : 대입연산자를 통해 오른쪽의 참조값을 왼쪽의 참조 벼수에 저장한다 

2. 생성자(Constructor)
	클래스 이름뒤에 소괄호가 있는 형태, 메소드와 비슷하지만 메소드라고 부르지 않는다
	생성자는 리턴이라는 기능이 존재하지 않는다.
	객체가 생성될 때 자동으로 실행되며, 주로 클래스의 필드를 초기화하는 데 사용된다

1) 생성자의 특징
	클래스 이름과 동일한 이름을 사용한다
	반환타입을 명시하지 않는다(void도 사용하지 않는다)
	객체 생성 시 new 키워드를 통해 호출되며 직접 호출할 수 없다
	생성자를 정의하지 않으며너 기본생성자(매개변수가 없는 생성자)가 자동으로 추가가된다
		- 하지만 개발자가 생성자를 하나라도 정의하면 기본 생성자는 자동으로 만들어지지 않는다.

2) 기본 생성자
	public 클래스명(){}
	매개변수가 없다
	클래스를 선언하면 자동으로 선언되며, 개발자가 직접 생성자를 선언하게 되면 자동으로 만들어주지 않는다



3. this
	객체 자기자신을 의미한다 -> 객체 자신의 참조값을 담고 있다
	this는 자동 생성되는 변수이다

	★ 현재 객체 자신을 참조하는 특별한 키워드이고 클래스 내부에서 필드와 메소드를 가리킬 때 사용한다

1) this 키워드를 사용하는 이유 
	필드와 지역변수의 이름이 동일할 때 구분하기 위해서
	가독성 향상
	다른 생성자 호출 및 메소드 체이닝 구현	

+) this : 객체 자기자신(참조값)

2) this의 좋은 사용법
	this를 활용해 의도를 명확히 하고 혼동을 방지
	this()를 활용해 중복 코드 제거 및 생성자 체이닝 구현

4. 다형성(polymorphism)
	하나의 것이 여러 형태를 가질 수 있는 성질
	오버로딩 : 같은 이름으로 매개변수의 타입, 순서, 개수가 다른 것을 선언하는 것
		메소드, 생성자

1) 생정자 오버로딩(Constructor Overloading)
	하나의 클래스에 여러 생성자를 정의할 수 있다
	각 생성자는 매개변수의 개수나 타입, 순서가 달라야한다

2) 기본생성자 자동생성 조건
	사용자가 생성자를 정의하지 않은 경우 컴파일러(JDK에 있다.javac.exe)가 기본 생성자를 자동으로 추가한다
	하지만 사용자가 매개변수가 있는 생성자를 정의하면 기본 생성자는 자동으로 만들어지지 않는다

5. this()
	자기자신의 생성자를 의미한다
	생성자 내부에서만 사용가능하며 최상단(첫번째줄)에 작성해야한다
	-> 생성자 내부에서 나의 다른 생성자를 호출할 때 사용한다

----------------------------------------------------------------------------------
복습
1) 메모리(Runtime Data Area) => JVM
	스택(Stack)
		메소드를 호출할 때마다 생성되는 프레임이 저장되는 영역
		프레임 내부에는 지역변수 스택이 있고 기본타입과 참조타입 변수가 생성되고 제거된다

	힙(Heap)
		객체, 배열이 생성되는 영역
		객체나 배열의 주소값은 메소드 영역과 스택영역의 상수와 변수에서 참조할 수 있다		

	메소드(Method)
		바이트 코드 파일을 읽은 내용이 저장되는 영역
		클래스별 상수, 정적필드, 메소드, 생성자 등이 저장된다

2) 클래스
	- 타입이다
	- 연관성이 있는 여러개의 타입과 기능을 한 곳에 모아서 편하게 관리할 수 있는 것
	- 객체를 생성하기 위한 틀, 설계도면

3) 클래스 구성 멤버
	class 클래스명{
		필드, 멤버변수 : 객체의 데이터가 저장되는 곳
		메소드, 멤버메소드 : 객체가 수행할 동작(행위, 행동, 상태)
		생성자 : new 키워드로 객체를 생성할 때 객체의 필드를 초기화 역할 담당
	}

4) 객체화(인스턴스화)
	객체를 만드는 작업
	추상적인 개념(클래스)를 구체화시키는 작업

	클래스명 객체명 = new 생성자(); (힙메모리에 저장)

5) 생성자(Constructor)
	new 기워드로 객체를 생성할 때 객체의 초기화 역할을 담당
	
	syso(new Person()); //이 참조값과
	syso(new Person()); //이 참고값의 결과는 다르다

	Person p = new Person(); 
	syso(p); // 같다

기본생성자와 매개변수가 있는 생성자
	public 클래스명(){}		=> 클래스명 객체명 = new 생성자();
					   객체명.num = 10;
	public 클래스명(int num){}	=> 클래스명 객체명 = new 생성자()10;

6) this, this()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자

7) 필드와 지역변수의 차이
	지역변수는 생성자와 메소드 블록에서 선언되고 생성자와 메소드 호출시에만 생성되고 사용된다
	필드는 클래스 블록 에서 선언되고 객체 내부에서 존재하고 객체 내부, 외부에서 사용가능하다

	구분	필드			지역변수
	선언위치	클래스 선언 블록		생성자, 메소드 선언 블록
	존재위치	객체 내부에서 존재		생성자, 메소드 호출시에만 존재
	사용위치	객체 내,외부 어디든 사용	생성자, 메소드 블록 내부에서만 사용

8) 메소드
- 메소드 선언
	리턴타임 메소드명(자료형 매개변수{
		실행할문장;
		return 리턴값;
	}

- 메소드 호출
	매개변수	리턴값	호출방식
	x	x	객체명.메소드명();
	o	x	객체명.메소드명(인수);
	x	o	syso(객체명.메소드명());	리턴타입과 같은 자료형 변수 = 객체명.메소드명();
	o	o	syso(객체명.메소드명(인수));	리턴타입과 같은 자료형 변수 = 객체명.메소드명(인수);

- 가변길이 매개변수
	리턴타입 메소드명(자료형 ... 매개변수명){
		실행할문장;
		return 리턴값;
	}

	메소드호출 : 매개변수 인수값을 쉼표로 구분해서 개수와 상관없이 사용가능함
	




1. 동물 클래스를 작성하세요
 필드(속성) : '이름', '나이', '종류'라는 필드
    - 이름 : 동물의 이름을 저장하는 곳
    - 나이 : 동물의 나이를 저장하는 곳
    - 종류 : 동물의 종류(개, 고양이, 새 등)를 저장하는 곳
 메서드(행동)
    - 밥먹기() : 동물이 밥을 먹는 행동을 하는 메서드
    - 놀기() : 동물이 노는 행동을 하는 메서드
    - 자다() : 동물이 자는 행동을 하는 메서드
    - 생일축하() : 동물의 생일을 축하하는 메서드

2. BasicTv 클래스를 작성하세요
필드 :
boolean power : TV 전원 상태 (기본값: false)
int channel : TV 채널 (기본값: 1)
String color : TV의 색상
int size : TV의 크기
int price : TV의 가격

메서드:
void powerOnOff() : TV 전원을 켜거나 끄는 메서드
      전원이 켜져 있으면 끄고, 꺼져 있으면 켜야 다른 동작이 가능하다
void channelUp() : 채널을 1씩 증가시키는 메서드
      채널 최대값 999
void channelDown() : 채널을 1씩 감소시키는 메서드
      채널 최소값 1

3. BasicTv 클래스와 함께 동작하는 TvController 프로그램을 작성하세요
   프로그램은 사용자로부터 명령을 입력받아 TV를 제어한다

   BasicTv 객체를 생성하고, 초기값으로 색상 "Black", 크기 32인치, 가격 500000원을 설정
   프로그램은 무한 반복(while)하며 사용자에게 다음 메뉴를 출력한다

=== TV 컨트롤 메뉴 ===
1. 전원 On/Off
2. 채널 올리기
3. 채널 내리기
4. 종료
메뉴 번호 입력 : 

사용자가 메뉴 번호를 입력하면, 입력된 번호에 따라 다음 동작을 수행한다
1 : powerOnOff() 메서드 호출
   전원이 켜지면 "TV 전원이 켜졌습니다." 출력, 꺼지면 "TV 전원이 꺼졌습니다." 출력
2 : TV 전원이 켜져 있으면 channelUp() 메서드 호출하고, "현재 채널: [채널 번호]"를 출력
   꺼져 있으면 "TV 전원을 먼저 켜주세요." 메시지 출력
3 : TV 전원이 켜져 있으면 channelDown() 메서드를 호출하고, "현재 채널: [채널 번호]"를 출력합니다. 꺼져 있으면 "TV 전원을 먼저 켜주세요." 메시지 출력
그 외 : 프로그램을 종료하고 "프로그램을 종료합니다." 메시지 출력

메모장 파일에 p228~242의 내용 읽고 이해한 대로 작성












