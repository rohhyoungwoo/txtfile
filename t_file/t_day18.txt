day18

* QR 확인하기
* 오늘 9시 5분 자리 변경
	* 기존 본인 자리에 착석 PC에 d드라이브 확인 
		-> 본인 폴더 메일로 보낸 후 완전 삭제 할 것
* 주말동안 공부한 것 정리해서 공유할 것(토요일/일요일 공부 시간 같이 작성)
	ex) 배열(예제코드 코드해석)
	    컬렉션 프레임워크 교재 예제 코드, 수업 예제 코드 해석 및 코드작성
--------------------------------------------------------------------------------
자리변경 -> 교재정리 -> 복습 -> 컬렉션 프레임워크(Map) -> DBMS

0. 복습
1) 예외처리
	프로그램이 비정상적인 종료를 막고 정상적으로 종료될 수 있도록 하기 위함
		
- 예외 종류
	일반예외	: 컴파일시 반드시 확인
		Exception를 상속
	실행예외 : 컴파일 시는 확인되지 않고 실행 중에 발생
		RuntimeExcetion를 상속
	Error	: JVM에서 발생하며 복구 불가능
		
- 예외처리 구문
	try{
	}catch(예외타입 참조변수){
	}..{
	}finally{
	}

- throws	
	메소드 선언부에 사용하여 예외처리를 메소드를 사용하는 쪽에서 진행

- throw
	예외 강제 발생시키기

- 사용자 정의 예외클래스
	새로운 예외 클래스를 만들어서 예외상황을 처리하는 것을 의미
	extends Exception 나	extends RuntimeException을 상속받아 만들어야한다

2) 컬렉션 프레임워크
	컬렉션 : 객체들을 효율적으로 저장하고 관리하기 위한 클래스의 집합
	컬렉션 프레임워크 : 데이터 구조와 알고리즘을 제공하는 표준화된 클래스 및 인터페이스 모음

- List	순서가 있는 데이터의 집합, 중복 허용
	구현 클래스 : ArrayList 
- Set	순서가 없는 데이터의 집합, 중복 허용하지 않음
	구현 클래스 : hashSet
- Map	키(key)-값(value) 한쌍으로 구성된 데이터, 키는 중복 불가
	구현 클래스 : hashMap

1. 컬렉션 프레임워크(Map)
1) Map
	데이터의 순서를 보장하지 않는다
	데이터를 Key와 Value 한쌍으로 저장하여 Key로 데이터에 접근할 수 있다
	key는 ArrayList의 index와 비슷한 역할을 하며 중복을 허용하지 않는다(index에 중복이 없는 것과 동일)

2) 구현클래스
	HashMap
	hashCode()가 반환하는 해시코드를 이용하며 검색속도가 상대적으로 빠르다
	이미 저장된 key를 가진 한쌍의 데이터를 넣으면 가장 마지막에 넣은 value로 수정된다(value는 수정 가능)
	저장되지 않은 key를 가진 한쌍의 데이터를 넣으면 새롭게 추가가 된다

3) Hash
	데이터를 다루는 기법, map처럼 key와 value로 이루어져있다
	키(key) 해시함수(hash function)를 통해 해시(hash)로 변경이 되며 
	해시는 값(value)과 매칭되어 저장소에 저장이된다

- 키(key) : 고유한 값이며 해시함수의 input, 다양한 길이의 값이 될 수 있다
	이 상태로 최종 저장소에 저장된다면 다양한 길이만큼의 저장소를 구성해야하므로 해시함수로 값을 바꾸어 저장이 되어야
	공간을 효율성을 추구할 수 있다
- 해시함수(Hash Function) : 키(key)를 해시(hash)로 바꿔주는 역할을 한다
	다양한 길이를 가지고 있는 키(key)를 일정한 길이를 가지는 해시(hash)로 변경하여 저장소를 효율적으로 운영할 수 있도록
	도와준다
	다만, 서로 다른 키(key)가 같은 해시(hash)가 되는 경우를 해시 충돌(hash Collision)이라고 하는데 해시 충돌을
	일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요하다
- 해시(hash) : 해시 함수의 결과물, 저장소(bucket, slot)에서 값(value)과 매칭되어 저장된다
- 값(value) : 저장소(bucket, slot)에 최종적으로 저장되는 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능해야한다

+) 해시테이블(hash table)
	데이터를 key와 value 쌍으로 데이터를 저장하는 자료구조
	키를 해시함수에 입력하여 해시값 또는 인덱스를 계산하고 계산된 인덱스를 통해 값을 저장하거나 조회 가능
	키를 기반으로 데이터를 저장하므로 중복키는 불가능하다

	- 장점 : 빠른 데이터 검색(조회), 삽입, 삭제 / 간단한 구현
	- 단점 : 해시 충돌이 발생하면 성능 저하 가능성, 해시 함수 설계에 따라 효율성이 달라짐
	- 중복 데이터 탐지, 캐시 구현, 데이터베이스의 인덱싱 등

4) Entry
	java 컬렉션 프레임워크에서 키-값 쌍을 표현하는 인터페이스
	주로 Map 인터페이스와 함께 사용된다

	Entry<K, V>는 Map 인터페이스 내부에 정의된 중첩 인터페이스 Map.Entry<k, v>
	한 개의 키와 그에 대응하는 값을 저장하는 구조를 제공한다
	Map의 모든 요소를 순회하거나 키와 값을 개별적으로 처리할 때 사용한다
	
Map.Entry의 메소드
	k getKey()	이 엔트리의 키를 반환
	v getValue()	이 엔트리의 값을 반환
	v setValue(V value)	엔트리의 값을 주어진 값으로 설정하고 이전 값을 반환
	boolean equals(Object o) 다른 객체와 이 엔트리를 비교
	int hashCode()		이 엔트리의 해시코드를 반환
	entrySet() 	Set<Map.Entry<K, V>>형태로 Map의 모든 키와 값 쌍을 순회

* 컬렉션 프레임워크 팀플 진행
* 팀명 / 팀장
* 모든 팀원이 1개 이상의 기능을 구현한다
* 어떻게 분배할 지 생각, (노션) notion -> 전체 코드 올라갈 수 있도록하기
	팀장은 모든 코드 취합하여 실행하기
* 모든 코드에 로직구성, 주석달아서 내가 쓴 코드 해석까지 진행

1. UserVO 클래스와 UserService 클래스를 선언하여 아래 요구사항에 맞춰 구현하기
- UserVO 클래스
	유저번호, 아이디, 비밀번호, 이름, 나이
	모든 필드는 private으로 선언하고 생성자를 통해서만 초기화한다
	toString() 재정의하여 모든 필드의 값을 확인할 수 있도록해야하며 유저 번호 값으로 객체의 동일성을 비교한다
- UserService 클래스
	회원정보를 저장할 List를 private으로 선언한다
	아이디 중복검사 메소드
	회원가입 메소드
	로그인 메소드
- Main 클래스
	객체 3개 생성, 오버라이딩 된 메소드 포함한 모든 메소드 출력
	
2. Employee 클래스와 EmployeeService 클래스를 선언하여 아래 요구사항 맞춰 구현하기 
	Main클래스
- 회사 직원들의 정보를 HashMap에 저장한다
	HashMap의 key는 사원의 Id(String), value는 이름, 나이, 부서로 설정
	필드는 private
- 조건1. 	새로운 사원정보를 추가
	각 팀원들 이름, 나이, 부서(개발부서 or 보안부서 중 택1)
- 조건2. 특정 ID(팀장)의 사원정보를 출력
- 조건3. 모든 사원의 정보 출력(반드시 entrySet 사용)
- 조건4. 모든 사원 정보에 연봉 추가(연봉은 3000으로 통일)
- Object 클래스의 메소드 오버라이딩 필수(사원의 ID가 동일하면 같은 사원으로 본다)

* 12시 50분까지 분배 진행
* 12시 50분 ~ 14시	점심
* 14시 ~ 14시 40분	팀별 코드 완성


팀명 : 데웹이
팀장: 김태현
팀원 : 배지수, 송명진, 조은혜, 윤지수, 신동석, 노형우

팀명 : I(2.0)
팀장 : 임초현
팀원 : 문준혁, 박승우, 이승아, 강후현, 허준혁, 길진수, 황어진

팀명 : 저장공간
팀장 : 김은혜
팀원 : 박수현 고현섭 오현택 박우열 김승현 조성현
















