day13
시험2문제 -> 과제 3문제 -> 복습 -> Casting

0. 복습
1) 상속(inheritance)
	부모가 자식에게 물려주는 행위를 의미함
	중복되는 코드를 줄여 개발 시간을 단축시킬 수 있다

	부모클래스, 슈퍼클래스 : 부모클래스의 멤버를 상속해주는 클래스
	자식클래스, 서브클래스 : 부모 멤버를 상속받는 클래스

2) 상속 문법
	class 부모클래스명{
		//부모 클래스의 멤버
	}
	
	class 자식클래스명 extends 부모클래스명{
		//자식 클래스의 멤버
		//부모 클래스의 멤버
	}

3) 생성자 : 필드의 초기화
	this	: 객체 자기자신(참조값)
	this()	: 자기자신의 생성자 => 생성자 오버로딩
	super	: 부모의 참조값
	super() : 부모의 생성자 => 자식클래스의 생성자 맨 첫번째 줄에 작성
	
4) 다형성 : 하나의 것으로 여러 형태를 가진다
	오버로딩	: 생성자, 메소드 / 매개변수의 개수, 순서, 타입을 다르게 같은 이름으로 선언할 수 있다
	오버라이딩	 : 상속받은 자식클래스의 메소드 / 메소드의 선언부는 동일, 구현부만 다르게 정의하는 것을 의미한다(재정의)

5) 접근제한자
	접근제한자		제한대상			제한범위
	public		클래스, 필드, 생성자, 메소드	없음
	protected	필드, 생성자, 메소드		같은 패키지거나 자식 객체만 사용가능
	(default)	클래스, 필드, 생성자, 메소드	같은 패키지
	private		필드, 생성자, 메소드		같은 클래스


1. 접근제한자
	private 접근제한자를 사용하여 필드에 직접 접근하지 못하도록 하고 대신 getter와 setter 메소드를 이용해
		값을 읽고 쓸 수 있다
		외부 클래스에서 직접 접근할 수 없다
	
	setter 메소드와 getter(단축키 : alt + shift + s + r)
	setter 	매개변수로만 값을 저장하는 메소드, 리턴타입 void
		메소드명은 setter에서 set을 따오고 + 필드이름(첫글자는 대문자)
		매개변수의 타입은 필드 타입으로 설정
	getter	값을 외부로 반환(리턴)할 때 사용하는 메소드, 리턴타입은 필드의 타입
		메소드명은 getter에서 set을 따오고 + 필드이름(첫글자는 대문자)
		리턴값은 필드값

1) 캡슐화(Encapsulation)
	객체지향 프로그래밍(OOP) 핵심 개념 중 하나
	데이터(필드)와 메소드를 하나의 단위로 묶고, 외부에서 직접 접근할 수 없도록 보호하는 것을 의미한다
	- 데이터 보호
	- 인터페이스 제공
	- 코드 유지보수성

2) 무결성(Integrity)
	데이터를 올바르고 일관성있게 유지하는 것을 의미한다
	캡슐화를 통해 데이터를 보호하고 유효성 검사를 통해 무결성을 보장할 수 있다
	- private 접근제한자 : 데이터를 직접 수정하지 못하게 보호
	- getter, setter : 데이터를 읽거나 쓸 때 유효성 검사를 통해 잘못된 값이 설정되지 않도록 함
	- 데이터의 상태를 변경할 때 조건을 부여해 항상 일관된 상태를 유지

2. Casting ★★★★★
	기본자료형끼리의 형변환, 기본자료형과 String 형변환
	클래스 자료형간의 형변환

1) Up casting, Down casting
	★ 부모값을 자식 타입으로 형 변환시 오류 발생
	★★★ 자식클래스 타입의 객체는 부모클래스 타입도 동시에 갖는다
	Up casting : 자식 값을 부모 타입으로 형변환(자동 타입 변환)
		부모타입 변수 = 자식타입객체;

	Down casting : 이미 up casting 된 객체를 자식타입으로 형변환

2) Up casting
	자식 클래스 객체를 부모 클래스 타입의 참조변수로 참조하는 것을 의미

	부모 클래스 타입의 참조변수로 자식 클래스의 객체를 가리킬 수 있다
	업 캐스팅 후에는 부모 클래스의 멤버(필드와 메소드)에만 접근할 수 있다
	자식 클래스의 멤버는 참조할 수 없지만 객체 내부에는 여전히 자식 클래스의 멤버가 존재한다
	명시적 캐스팅이 생략 가능	

3) down casting
	부모 클래스 타입의 참조변수를 다시 자식 클래스 타입으로 변환하는 것을 의미
	
	업캐스팅 된 객체를 다시 자식 클래스 타입으로 변환해야한다
	명시적 캐스팅이 필요하다
	다운 캐스팅 후에는 자식 클래스의 멤버(필드와 메소드)에 접근할 수 있다
	잘못된 다운캐스팅(부모 객체를 자식 타입으로 변환 시도)는 ClassCastException 오류 발생한다

4) Casting을 사용하는 이유
	부모타입인 하나의 저장공간에 여러 자식 타입의 참조값을 업캐스팅하여 저장할 수 있다(참조변수의 다형성)
	만약 하나의 기능을 하는 메소드를 만들 때 매개변수로 여러 자식타입을 받아야한다고 가정해보자
	casting이 없었다면 자식 타입을 매개변수로 받는 메소드를 타입별로 각각 만들어야한다
	(자식끼리는 타입이 다르기 때문이다)
	casting을 활용하면 부모 타입의 매개변수를 가진 하나의 메소드만 만들면된다
	(부모타입의 참조변수로 모든 자식타입을 저장할 수 있기 때문이다)

	※ 주의사항
	* Up casting으로 자식의 참조값을 저장했다면 자식클래스에 오버라이딩(재정의)된 기능이 실행된다
	* Up casting으로 자식 참조값을 저장했다면 자식클래스에서 구현한 기능들은 사용할 수가 없다
	이 경우 Down casting을 통해서 복구하고 사용한다

5) 다형성
	하나의 것이 여러가지 형태를 가질 수 있는 성질
	- 오버로딩 : 생성자, 메소드	
		같은 이름으로 매개변수의 타입, 순서, 개수가 다르면 선언할 수 있다
		반환타입은 영향을 끼치지 않는다
	- 오버라이딩 : 상속받은 자식 클래스의 메소드
		부모 클래스에 정의된 메소드 선언부를 그대로 쓰고 구현부만 재정의한다
		선언부는 무조건 똑같아야한다
	- 참조변수의 다형성(매개변수의 다형성)
		부모 클래스타입의 참조변수로 자식 클래스 객체를 가리키는 것을 허용하는 것을 의미한다

6) 객체 간 타입 비교
	객체명 instanceof 클래스명
	a instanceof A : 조건식, 참 거짓 중 하나가 나오는 식
		a가 A 타입이면 true
		a가 A 타입이 아니면 false





팀마다 2개씩 선정
	설치하기, 변수, 자료형, 출력메소드, 형변환, 입력메소드, 연산자, 제어문, 배열, 
	메소드, 클래스, 상속, enum, final, 접근제한자, casting


택1 : 형변환, 입력메소드, 연산자, 제어문, 배열
택1 : 메소드, 클래스, 상속, 접근제한자, casting

=> 개념 / 문제(코드작성X)
- 입력메소드, 메소드	
- 배열, 상속		
- 형변환, 클래스		
- 제어문, 접근제한자	
- 연산자, casting		

개념 내용 관련과 로직 내용은 무조건 포함
문제는 4문제 이하로

16시 50분 ~ 17시 쉬는시간
17시 30분까지 문제 만들기

** 내일 문제 풀기
1 I팀 		- 공백(0100) 	2문제(1번 승아, 2번 후현)
2 공백(0100) 	- JAVA요		3문제(2번 우열, 3번 지수1)
3 JAVA요 	- 보안ER		3문제(1번 동석, 2번 승우, 3번 형우)
4 보안ER 	- JAV탕		2문제(2번 초현, 1번 준혁2)
5 JAV탕 		- I팀		4문제(3번 진수, 2번 명진)



































